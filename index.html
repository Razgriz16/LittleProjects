<!DOCTYPE html>
<html>
<head>
    <title>3D Cone on a 3D Plane</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>



//0x00ff00



class Cone {
    constructor(scene) {
        this.geometry = new THREE.ConeGeometry(0.7, 2, 10);
        this.material = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        this.mesh = new THREE.Mesh(this.geometry, this.material);
        this.mesh.rotation.x = Math.PI / -2;
        this.mesh.position.z = 5;
        scene.add(this.mesh);
    }
    move(direction) {
        switch (direction) {
            case 'left':
                this.mesh.position.x -= 0.13;
                break;
            case 'right':
                this.mesh.position.x += 0.13;
                break;
            case 'up':
                this.mesh.position.z -= 0.13;
                break;
            case 'down':
                this.mesh.position.z += 0.13;
                break;
        }
    }
    rotate(direction) {
        switch (direction) {
            case 'left':
                this.mesh.rotation.z += 0.06;
                break;
            case 'right':
                this.mesh.rotation.z -= 0.06;
                break;
        }
    }
}
class Bullet {
    constructor(scene, position, rotation) {
        this.geometry = new THREE.BoxGeometry(0.3, 0.3, 0.5);
        this.material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        this.mesh = new THREE.Mesh(this.geometry, this.material);
        this.mesh.position.copy(position);
        this.mesh.position.y += 0.5;
        this.mesh.rotation.copy(rotation);
        this.mesh.rotateX(Math.PI / -2);
        scene.add(this.mesh);
        // Store the initial rotation of the bullet
       this.initialRotation = this.mesh.rotation.clone();
    }
    move() {
        const direction = new THREE.Vector3(0, 0, -1); // Initial direction
        // Apply the bullet's rotation to the direction vector
        direction.applyQuaternion(this.mesh.quaternion);
        // Move the bullet in the direction it's facing
        this.mesh.position.add(direction.multiplyScalar(-0.3)); // Adjust the speed as needed
    }
}
class Controls {
    constructor() {
        this.keyControls = {
            left: false,
            right: false,
            up: false,
            down: false
        };
        this.keyControlsArrow = {
            left: false,
            right: false,
            up: false,
            down: false
        };
        document.addEventListener('keydown', (event) => {
            this.onKeyDown(event);
        });
        document.addEventListener('keyup', (event) => {
            this.onKeyUp(event);
        });
    }
    onKeyDown(event) {
        switch (event.key) {
            case 'a':
                this.keyControls.left = true;
                break;
            case 'd':
                this.keyControls.right = true;
                break;
            case 'w':
                this.keyControls.up = true;
                break;
            case 's':
                this.keyControls.down = true;
                break;
            case 'ArrowLeft':
                this.keyControlsArrow.left = true;
                break;
            case 'ArrowRight':
                this.keyControlsArrow.right = true;
                break;
            case 'ArrowUp':
                this.keyControlsArrow.up = true;
                break;
            case 'ArrowDown':
                this.keyControlsArrow.down = true;
                break;
        }
    }
    onKeyUp(event) {
        switch (event.key) {
            case 'a':
                this.keyControls.left = false;
                break;
            case 'd':
                this.keyControls.right = false;
                break;
            case 'w':
                this.keyControls.up = false;
                break;
            case 's':
                this.keyControls.down = false;
                break;
            case 'ArrowLeft':
                this.keyControlsArrow.left = false;
                break;
            case 'ArrowRight':
                this.keyControlsArrow.right = false;
                break;
            case 'ArrowUp':
                this.keyControlsArrow.up = false;
                break;
            case 'ArrowDown':
                this.keyControlsArrow.down = false;
                break;
        }
    }
}


class MovingSphere {
    constructor(scene, planeSize) {
        this.geometry = new THREE.SphereGeometry(1, 32, 32);
        this.material = new THREE.MeshBasicMaterial({ color: 0x808080 });
        this.mesh = new THREE.Mesh(this.geometry, this.material);
        this.planeSize = planeSize;
        this.direction = 1; // Initial direction: 1 for right, -1 for left
        this.speed = 0.08; // Adjust the speed of movement as needed
        this.mesh.position.x = -planeSize / 3; // Start at the left edge
        this.mesh.position.z = -5; // Start at the center
        this.mesh.position.y = 0.5; // Adjust as needed to avoid overlapping with the plane
        scene.add(this.mesh);
    }

    moveWithinLimits() {
        const halfPlaneSize = this.planeSize / 3;
        this.mesh.position.x += this.direction * this.speed;

        // Check if the sphere reaches the right or left limit
        if (this.mesh.position.x >= halfPlaneSize || this.mesh.position.x <= -halfPlaneSize) {
            this.direction *= -1; // Change direction
        }
    }
}

class Plane {
    constructor(scene, size) {
        this.size = size;
        this.createPlane(scene);
        this.createWalls(scene);
    }

    createPlane(scene) {
        const planeGeometry = new THREE.BoxGeometry(this.size, 0.1, this.size);
        const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc });
        this.plane = new THREE.Mesh(planeGeometry, planeMaterial);
        this.plane.position.y = -1.55;
        scene.add(this.plane);
    }

    createWalls(scene) {
        const wallMaterial = new THREE.MeshBasicMaterial({ color: 0x999999 });

        // Left wall
        const leftWallGeometry = new THREE.BoxGeometry(0.1, 2, this.size);
        this.leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
        this.leftWall.position.x = -this.size / 2;
        this.leftWall.position.y = -0.5;
        scene.add(this.leftWall);

        // Right wall
        const rightWallGeometry = new THREE.BoxGeometry(0.1, 2, this.size);
        this.rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
        this.rightWall.position.x = this.size / 2;
        this.rightWall.position.y = -0.5;
        scene.add(this.rightWall);

        // Front wall
        const frontWallGeometry = new THREE.BoxGeometry(this.size, 2, 0.1);
        this.frontWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
        this.frontWall.position.z = -this.size / 2;
        this.frontWall.position.y = -0.5;
        scene.add(this.frontWall);

        // Back wall
        const backWallGeometry = new THREE.BoxGeometry(this.size, 2, 0.1);
        this.backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
        this.backWall.position.z = this.size / 2;
        this.backWall.position.y = -0.5;
        scene.add(this.backWall);
    }
}
//scene
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.z = 10;
camera.position.y = 15;
camera.rotation.x = (299 * Math.PI) / 180;
// Renderer
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Create Cone
const player = new Cone(scene);

// Create a moving sphere
const movingSphere = new MovingSphere(scene, 25); // Assuming the plane has a size of 25

//create plane
const plano = new Plane(scene, 25);

// Bullets
const bullets = [];
const controls = new Controls();
let shootBullet = false;
let lastBulletTime = Date.now();
document.addEventListener('keydown', (event) => {
    switch (event.key) {
        case ' ':
            shootBullet = true;
            break;
    }
});
document.addEventListener('keyup', (event) => {
    switch (event.key) {
        case ' ':
            shootBullet = false;
            break;
    }
});

// Render
function render() {
    requestAnimationFrame(render);
    // Move the cone based on keyboard input
    if (controls.keyControls.left) player.move('left');
    if (controls.keyControls.right) player.move('right');
    if (controls.keyControls.up) player.move('up');
    if (controls.keyControls.down) player.move('down');
    // Rotate the cone based on keyboard input
    if (controls.keyControlsArrow.left) player.rotate('left');
    if (controls.keyControlsArrow.right) player.rotate('right');
    //sphere
    movingSphere.moveWithinLimits();
    // Shoot bullets
    if (shootBullet) {
        const currentTime = Date.now();
        if (currentTime - lastBulletTime > 90) { // Shoot a bullet every 200ms
            const bullet = new Bullet(scene, player.mesh.position, player.mesh.rotation);
            bullets.push(bullet);
            lastBulletTime = currentTime;
        }
    }
    // Move bullets
    for (let i = 0; i < bullets.length; i++) {
        const bullet = bullets[i];
        bullet.move();
        if (bullet.mesh.position.z < -15) { // Remove bullets that are off-screen
            scene.remove(bullet.mesh);
            bullets.splice(i, 1);
            i--;
        }
    }
    renderer.render(scene, camera);
}
render();
    </script>
</body>
</html>
